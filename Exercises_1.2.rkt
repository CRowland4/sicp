#lang scheme

; 1.9 - Illustrate the processes generated by each of these two procedures in evaluating (+ 4 5). Are they iterative or recursive processes?
#|
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
|#
; Commented out so redefining the + operator doesn't throw an error

; (+ 4 5)
; (if (= 4 0) 5 (inc (+ (dec 4) 5)))
; (inc (+ (dec 4) 5))
; (inc (+ 3 5))
; (inc (if (= 3 0) 5 (inc (+ (dec 3) 5))))
; (inc (inc (+ 2 5)))
; (inc (inc (if (= 2 0) 5 (inc (+ (dec 2) 5)))))
; (inc (inc (inc (+ 1 5))))
; (inc (inc (inc (if (= 1 0) 5 (inc (+ (dec 1) 5))))))
; (inc (inc (inc (inc (+ 0 5)))))
; (inc (inc (inc (inc (if (= 0 0) 5 (inc (+ (dec 0) 5)))))))
; (inc (inc (inc (inc 5))))
; (inc (inc (inc 6)))
; (inc (inc 7))
; (inc 8)
; 9
; This is a recursive process - we got down to the point where the base case executes, then backtracked through all of the saved "inc"s that had to be kept track of to get the answer

#|
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))
|#
; Commented out so redefining the + operator doesn't throw an error

; (+ 4 5)
; (if (= 4 0) 5 (+ (dec 4) (inc 5)))
; (+ (dec 4) (inc 5)))
; (+ 3 6)
; (if (= 3 0) 6 (+ (dec 3) (inc 6)))
; (+ (dec 3) (inc 6)))
; (+ 2 7)
; (if (= 2 0) 7 (+ (dec 2) (inc 7)))
; (+ (dec 2) (inc 7)))
; (+ 1 8)
; (if (= 1 0) 8 (+ (dec 1) (inc 8)))
; (+ (dec 1) (inc 8)))
; (+ 0 9)
; (if (= 0 0) 9 (+ (dec 0) (inc 9)))
; 9

; This is an iterative process - the substitution method shows that this was a simple repetition of the same procedure over and over, with no backtracking at the end.
;     At each third step, we had a completely isolated call to the + procedure that didn't have to "pass" information to anything before it - its output was the entire answer



; Exercise 1.10
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

(A 1 10)
; (A 0 (A 1 9))
; (A 0 (A 0 (A 1 8)))
; (A 0 (A 0 (A 0 (A 1 7))))
; (A 0 (A 0 (A 0 (A 0 (A 1 6)))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 32)))))
; (A 0 (A 0 (A 0 (A 0 64))))
; (A 0 (A 0 (A 0 128)))
; (A 0 (A 0 256))
; (A 0 512)
; 1024

(A 2 4)
; (A 1 (A 2 3))
; (A 1 (A 1 (A 2 2)))
; (A 1 (A 1 (A 1 (A 2 1))))
; (A 1 (A 1 (A 1 2)))
; (A 1 (A 1 (A 0 (A 1 1))))
; (A 1 (A 1 (A 0 2)))
; (A 1 (A 1 4))
; (A 1 (A 0 (A 1 3)))
; (A 1 (A 0 (A 0 (A 1 2))))
; (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
; (A 1 (A 0 (A 0 (A 0 2))))
; (A 1 (A 0 (A 0 4)))
; (A 1 (A 0 8))
; (A 1 16)
; (A 0 (A 1 15))
; (A 0 (A 0 (A 1 14)))
; This will give us 15 nested (A 0 (A 0....)) ending in an (A 1 1), which evaluates to (A 0 2). So the answer will be 2 raised to the 16 power, or 65536

; The first problem, (A 1 10), ended up being 2^(1^10). The second problem, (A 2 4), ended up being 2^(2^4). So I'm going to infer
;     that (A 3 3) is 2^(3^3) = 2^27 = 134217728

; I was wrong, so I I'm gonna do this one manually as well to get a feel for why I was wrong

(A 3 3)
; (A 2 (A 3 2))
; (A 2 (A 2 (A 3 1)))
; (A 2 (A 2 2))
; (A 2 (A 1 (A 2 1)))
; (A 2 (A 1 2))
; (A 2 (A 0 (A 1 1)))
; (A 2 (A 0 2))
; (A 2 4)
; From the previous problem, we know this is 65536


(define (f n) (A 0 n))
; (f n) is the function 2n

(define (g n) (A 1 n))
; (A 1 n)
; (A 0 (A 1 (n-1)))
; = 2 * (A 1 (n-1)
; = 2^(n - 1) (A 1 1)
; = 2^(n - 1) * 2
; = 2^n
; (g n) is the function 2^n

(define (h n) (A 2 n))
; (A 2 n)
; (A 1 (A 2 (n-1)))
; 2^(A 2 (n-1))
; 2^(A 1 (A 2 (n-2)))
; 2^(2^(A 2 (n-2)))
; ...
; Every increment of n by 1 produces another 2 in this compound exponent. So there will be n total exponents stacked on top of the two, which calls for
;    the mathematical double-arrow notation.
; So (h n) is the function 2 (double-up-arrow) n. Recursively, this would be defined as 2^h(n-1) (in mathematical notation, not LISP notation)



; 1.11
; Recursive
(define (recursive-func n)
  (if (< n 3)
      n
      (+ (recursive-func (- n 1)) (* 2 (recursive-func (- n 2))) (* 3 (recursive-func (- n 3))))))
(recursive-func 10)

; Iterative
(define (iterative-func n)
  (if (< n 3)
      n
      (iter-func 2 1 0 n 3)))
(define (iter-func minus-1 minus-2 minus-3 end current)
  (if (= end current)
      (+ minus-1 (* 2 minus-2) (* 3 minus-3))
      (iter-func (+ minus-1 (* 2 minus-2) (* 3 minus-3)) minus-1 minus-2 end (+ current 1))))
(iterative-func 10)



; Exercise 1.12
(define (recursive-pascal layer digit)
  (if (or (= digit 1) (= digit layer))
      1
      (+ (recursive-pascal (- layer 1) (- digit 1))
         (recursive-pascal (- layer 1) digit))))



; Exercise 1.13 - Math proof, done in Liquid Text



; Exercise 1.14 - Hand-draw a tree for a recursive process, done in Liquid Text



; Exercise 1.15
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
(sin 12.15)

; a) (sin 12.5) -> (sin 4.17) -> (sin 1.38) -> (sin 0.64) -> (sin 0.15) -> (sin 0.05) ----- 6 steps
; b) Since each angle is divided by three until a threshold, the space and time complexities are both O(log(a))



; Exercise 1.16
(define (iterative-fast-exponentiation b n)
  (iter-exp 1 b (- n 1)))
(define (iter-exp a b n)
  (cond ((= n 0) a)
        ((even? n) (iter-exp (* a b b) b (/ n 2)))
        (else (iter-exp (* a b) b (- n 1)))))
(define (even? n)
  (= (remainder n 2) 0))
(iterative-fast-exponentiation 3 3)
                

      
      