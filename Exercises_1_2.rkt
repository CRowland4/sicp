#lang scheme

; 1.9 - Illustrate the processes generated by each of these two procedures in evaluating (+ 4 5). Are they iterative or recursive processes?
#|
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
|#
; Commented out so redefining the + operator doesn't throw an error

; (+ 4 5)
; (if (= 4 0) 5 (inc (+ (dec 4) 5)))
; (inc (+ (dec 4) 5))
; (inc (+ 3 5))
; (inc (if (= 3 0) 5 (inc (+ (dec 3) 5))))
; (inc (inc (+ 2 5)))
; (inc (inc (if (= 2 0) 5 (inc (+ (dec 2) 5)))))
; (inc (inc (inc (+ 1 5))))
; (inc (inc (inc (if (= 1 0) 5 (inc (+ (dec 1) 5))))))
; (inc (inc (inc (inc (+ 0 5)))))
; (inc (inc (inc (inc (if (= 0 0) 5 (inc (+ (dec 0) 5)))))))
; (inc (inc (inc (inc 5))))
; (inc (inc (inc 6)))
; (inc (inc 7))
; (inc 8)
; 9
; This is a recursive process - we got down to the point where the base case executes, then backtracked through all of the saved "inc"s that had to be kept track of to get the answer

#|
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))
|#
; Commented out so redefining the + operator doesn't throw an error

; (+ 4 5)
; (if (= 4 0) 5 (+ (dec 4) (inc 5)))
; (+ (dec 4) (inc 5)))
; (+ 3 6)
; (if (= 3 0) 6 (+ (dec 3) (inc 6)))
; (+ (dec 3) (inc 6)))
; (+ 2 7)
; (if (= 2 0) 7 (+ (dec 2) (inc 7)))
; (+ (dec 2) (inc 7)))
; (+ 1 8)
; (if (= 1 0) 8 (+ (dec 1) (inc 8)))
; (+ (dec 1) (inc 8)))
; (+ 0 9)
; (if (= 0 0) 9 (+ (dec 0) (inc 9)))
; 9

; This is an iterative process - the substitution method shows that this was a simple repetition of the same procedure over and over, with no backtracking at the end.
;     At each third step, we had a completely isolated call to the + procedure that didn't have to "pass" information to anything before it - its output was the entire answer



; Exercise 1.10
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

; (A 1 10)
; (A 0 (A 1 9))
; (A 0 (A 0 (A 1 8)))
; (A 0 (A 0 (A 0 (A 1 7))))
; (A 0 (A 0 (A 0 (A 0 (A 1 6)))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
; (A 0 (A 0 (A 0 (A 0 (A 0 32)))))
; (A 0 (A 0 (A 0 (A 0 64))))
; (A 0 (A 0 (A 0 128)))
; (A 0 (A 0 256))
; (A 0 512)
; 1024

; (A 2 4)
; (A 1 (A 2 3))
; (A 1 (A 1 (A 2 2)))
; (A 1 (A 1 (A 1 (A 2 1))))
; (A 1 (A 1 (A 1 2)))
; (A 1 (A 1 (A 0 (A 1 1))))
; (A 1 (A 1 (A 0 2)))
; (A 1 (A 1 4))
; (A 1 (A 0 (A 1 3)))
; (A 1 (A 0 (A 0 (A 1 2))))
; (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
; (A 1 (A 0 (A 0 (A 0 2))))
; (A 1 (A 0 (A 0 4)))
; (A 1 (A 0 8))
; (A 1 16)
; (A 0 (A 1 15))
; (A 0 (A 0 (A 1 14)))
; This will give us 15 nested (A 0 (A 0....)) ending in an (A 1 1), which evaluates to (A 0 2). So the answer will be 2 raised to the 16 power, or 65536

; The first problem, (A 1 10), ended up being 2^(1^10). The second problem, (A 2 4), ended up being 2^(2^4). So I'm going to infer
;     that (A 3 3) is 2^(3^3) = 2^27 = 134217728

; I was wrong, so I I'm gonna do this one manually as well to get a feel for why I was wrong

; (A 3 3)
; (A 2 (A 3 2))
; (A 2 (A 2 (A 3 1)))
; (A 2 (A 2 2))
; (A 2 (A 1 (A 2 1)))
; (A 2 (A 1 2))
; (A 2 (A 0 (A 1 1)))
; (A 2 (A 0 2))
; (A 2 4)
; From the previous problem, we know this is 65536


(define (f n) (A 0 n))
; (f n) is the function 2n

(define (g n) (A 1 n))
; (A 1 n)
; (A 0 (A 1 (n-1)))
; = 2 * (A 1 (n-1)
; = 2^(n - 1) (A 1 1)
; = 2^(n - 1) * 2
; = 2^n
; (g n) is the function 2^n

(define (h n) (A 2 n))
; (A 2 n)
; (A 1 (A 2 (n-1)))
; 2^(A 2 (n-1))
; 2^(A 1 (A 2 (n-2)))
; 2^(2^(A 2 (n-2)))
; ...
; Every increment of n by 1 produces another 2 in this compound exponent. So there will be n total exponents stacked on top of the two, which calls for
;    the mathematical double-arrow notation.
; So (h n) is the function 2 (double-up-arrow) n. Recursively, this would be defined as 2^h(n-1) (in mathematical notation, not LISP notation)



; 1.11
; Recursive
(define (recursive-func n)
  (if (< n 3)
      n
      (+ (recursive-func (- n 1)) (* 2 (recursive-func (- n 2))) (* 3 (recursive-func (- n 3))))))

; Iterative
(define (iterative-func n)
  (if (< n 3)
      n
      (iter-func 2 1 0 n 3)))
(define (iter-func minus-1 minus-2 minus-3 end current)
  (if (= end current)
      (+ minus-1 (* 2 minus-2) (* 3 minus-3))
      (iter-func (+ minus-1 (* 2 minus-2) (* 3 minus-3)) minus-1 minus-2 end (+ current 1))))



; Exercise 1.12
(define (recursive-pascal layer digit)
  (if (or (= digit 1) (= digit layer))
      1
      (+ (recursive-pascal (- layer 1) (- digit 1))
         (recursive-pascal (- layer 1) digit))))



; Exercise 1.13 - Math proof, done in Liquid Text



; Exercise 1.14 - Hand-draw a tree for a recursive process, done in Liquid Text



; Exercise 1.15
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

; a) (sin 12.5) -> (sin 4.17) -> (sin 1.38) -> (sin 0.64) -> (sin 0.15) -> (sin 0.05) ----- 6 steps
; b) Since each angle is divided by three until a threshold, the space and time complexities are both O(log(a))



; Exercise 1.16
(define (iterative-fast-exponentiation b n)
  (iter-exp 1 b (- n 1)))
(define (iter-exp a b n)
  (cond ((= n 0) a)
        ((even? n) (iter-exp (* a b b) b (/ n 2)))
        (else (iter-exp (* a b) b (- n 1)))))
(define (even? n)
  (= (remainder n 2) 0))



; Exercise 1.17
(define (double x)
  (+ x x))
(define (halve x)
  (/ x 2))
(define (recursive-fast-multiplication a b)
  (cond ((= b 0) 0)
        ((= b 1) a)
        ((even? b) (recursive-fast-multiplication (double a) (halve b)))
        (else (+ a (recursive-fast-multiplication a (- b 1))))))



; Exercise 1.18
(define (iterative-fast-multiplication a b)
  (iter-fast-mult a b 0))
(define (iter-fast-mult a b leftover)
  (cond ((= b 0) 0)
        ((= b 1) (+ a leftover))
        ((even? b) (iter-fast-mult (double a) (halve b) leftover))
        (else (iter-fast-mult a (- b 1) (+ leftover a)))))



; Exercise 1.19
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p) (* q q))  ; This is p'
                   (+ (* 2 p q) (* q q))  ; This is q'
                   (/ count 2)))
        (else (fib-iter (+ (* b) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))



; Exercise 1.20
; Normal Order done in Liquid Text, took 4 remainder calculations
; Applicative Order (long, didn't want to write out in Liquid Text):


#|
(gcd 206 40)

(if (= 40 0)
    206
    (gcd (40 (remainder 206 40))))

(gcd (40 (remainder 206 40)))

(if (= (remainder 206 40) 0)
    40
    (gcd (remainder 206 40) (remainder (40 (remainder 206 40)))))

(if (= 6 0)  ; 1 remainder
    40
    (gcd (remainder 206 40) (remainder (40 (remainder 206 40)))))

(gcd (remainder 206 40) (remainder (40 (remainder 206 40))))

(if (= (remainder 40 (remainder 206 40)) 0)
    (remainder 206 40)
    (gcd (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

(if (= (remainder 40 6) 0)  ; 1 remainder
    (remainder 206 40)
    (gcd (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

(if (= 4 0)  ; 1 remainder
    (remainder 206 40)
    (gcd (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

(gcd (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))

(if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0)
    (remainder (40 (remainder 206 40)))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))

(if (= (remainder (remainder 206 40) (remainder 40 6)) 0)  ; 1 remainder
    (remainder (40 (remainder 206 40)))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))

(if (= (remainder (remainder 206 40) 4) 0)  ; 1 remainder
    (remainder (40 (remainder 206 40)))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))

(if (= (remainder 6 4) 0)  ; 1 remainder
    (remainder (40 (remainder 206 40)))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))

(if (= 2 0)  ; 1 remainder
    (remainder (40 (remainder 206 40)))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))

(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))

(if (= (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0)
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

(if (= (remainder (remainder 40 6) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0)  ; 1 remainder
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

(if (= (remainder 4 (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0)  ; 1 remainder
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

(if (= (remainder 4 (remainder 6 (remainder 40 (remainder 206 40)))) 0)  ; 1 remainder
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

(if (= (remainder 4 (remainder 6 (remainder 40 6))) 0)  ; 1 remainder
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

(if (= (remainder 4 (remainder 6 4)) 0)  ; 1 remainder
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

(if (= (remainder 4 2) 0)  ; 1 remainder
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

(if (= 0 0)  ; 1 remainder
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
    (gcd (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder (40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))

(remainder (remainder 206 40) (remainder 40 6))  ; 1 remainder

(remainder (remainder 206 40) 4)  ; 1 remainder

(remainder 6 4)  ; 1 remainder

2  ; 1 remainder

Applicative Order took 18 remainder calculations
|#



; Exercise 1.21
(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (* test-divisor test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b) (= (remainder b a) 0))

(find-divisor 199 2)
(find-divisor 1999 2)
(find-divisor 19999 2)



; Exercise 1.22
; Use the below procedure to define a procedure that checks the primality of consecutive odd integers in a specified range.
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n))
(define (start-prime-test n)
  (if (prime? n)
      (display " *** ")
      (display " NOT PRIME ")))
(define (report-prime elapsed-time)
  (display elapsed-time))
(define (prime? n)
  (= n (smallest-divisor n)))
(define (solution-procedure n end)
  (define n-in-range (< (- n 1) end))
  (define n-odd (= (remainder n 2) 1))
  (define n-even (= (remainder n 2) 0))
  (cond ((and n-in-range n-even) (solution-procedure (+ n 1) end))
        ((and n-in-range n-odd)
         (timed-prime-test n)
         (solution-procedure (+ n 1) end))
        ((not n-in-range) (display " END "))))

;(time (solution-procedure 1000 1020))  ; First three primes - 1009, 1013, 1019. Real Time taken reads as 0
;(time (solution-procedure 10000 10038))  ; First three primes - 10007, 10009, 100037. Real Time taken reads as 0
;(time (solution-procedure 100000 100045))  ; First three primes - 100003, 100019, 100043. Real Time taken still reads as 0
;(time (solution-procedure 1000000 1000038))  ; First three primes - 1000003, 1000033, 1000037. Real Time taken still reads as 0

;(time (solution-procedure 10000 20000))  ; Real time 327
;(time (solution-procedure 100000 200000))  ; Real time 3716
;(time (solution-procedure 1000000 2000000))  ; Real time 45439



; Exercise 1.23
(define (faster-timed-prime-test n)
  (newline)
  (display n)
  (faster-start-prime-test n))
(define (faster-start-prime-test n)
  (if (faster-prime? n)
      (display " *** ")
      (display " NOT PRIME ")))
(define (faster-prime? n)
  (= n (faster-smallest-divisor n)))
(define (faster-solution-procedure n end)
  (define n-in-range (< (- n 1) end))
  (define n-odd (= (remainder n 2) 1))
  (define n-even (= (remainder n 2) 0))
  (cond ((and n-in-range n-even) (faster-solution-procedure (+ n 1) end))
        ((and n-in-range n-odd)
         (faster-timed-prime-test n)
         (faster-solution-procedure (+ n 1) end))
        ((not n-in-range) (display " END "))))
(define (faster-smallest-divisor n)
  (faster-find-divisor n 2))
(define (faster-find-divisor n test-divisor)
  (cond ((> (* test-divisor test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (faster-find-divisor n (next test-divisor)))))
(define (next n)
  (if (= 2 n) 3
      (+ n 2)))


;(time (faster-solution-procedure 10000 20000))  ; Real time 305. 
;(time (faster-solution-procedure 100000 200000))  ; Real time 3516.
; It's faster, but not by half. This is most likely due to the fact that I can't use the exact functionality described in the exercises, because this Scheme implementation
;    doesn't have the same primitive procedure (runtime) that the book talks about. Printing to the screen in an IDE can also come with a lot of overhead, which may also be
;    causing a significant slowdown in large-quantity processes that would otherwise be very fast.



; Exercise 1.24
(define (fermat-solution-procedure n end)
  (define n-in-range (< (- n 1) end))
  (define n-odd (= (remainder n 2) 1))
  (define n-even (= (remainder n 2) 0))
  (cond ((and n-in-range n-even) (fermat-solution-procedure (+ n 1) end))
        ((and n-in-range n-odd)
         (fermat-timed-prime-test n)
         (fermat-solution-procedure (+ n 1) end))
        ((not n-in-range) (display " END "))))
(define (square n)
  (* n n))
(define (fermat-timed-prime-test n)
  (newline)
  (display n)
  (fermat-start-prime-test n))
(define (fermat-start-prime-test n)
  (if (fermat-prime? n 10)
      (display " *** ")
      (display " NOT PRIME ")))
(define (fermat-report-prime elapsed-time)
  (display elapsed-time))
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
(define (fermat-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fermat-prime? n (- times 1)))
        (else false)))
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder
          (square (expmod base (/ exp 2) m))
          m))
        (else
         (remainder
          (* base (expmod base (- exp 1) m))
          m))))

;(time (fermat-solution-procedure 10000 20000))  ; Real time 240. 
;(time (faster-solution-procedure 100000 200000))  ; Real time 2573.
;(time (solution-procedure 1000000 2000000))  ; Real time 33508
; These are all much faster times. The Fermat test significantly speeds things up, though it still seems like there's overhead somewhere, again I think it's due to the printing



; Exercise 1.25
#|
(define (expmod base exp m)
 (remainder (fast-expt base exp) m))
|#
; No, this would not serve us well for the prime test. The intermediate results are huge, and would consume far too much memory for checking sufficiently large primes.
; The current version of expmod uses mathematical identities to avoid actually having to deal with the value of base^exp.



; Exercise 1.26
(define (slow-expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base
                       (expmod base (- exp 1) m))
                    m))))
; This procedure runs much slower because the expression <(expmod base (/ exp 2) m)> is being calculated twice for every one time it's needed.
; Without going into the specific mathematics, this creates a binary tree-like structure, where the nodes is exponential in the number of steps. And since
;    exponents and logs are the inverse of each other, and the previous number of steps was about log(n), we're left with n now. So the process is an O(n) process.



; Exercise 1.27
(define (carmichael-test current n)
  (cond ((= current n) (display " END - Fermat test passed for all a < ")
                       (display n)
                       (newline))
        ((= (expmod current n n) (remainder current n)) (carmichael-test (+ current 1) n))
        (else (display "Fermat test failed for ")
              (display current))))

(carmichael-test 1 561)
(carmichael-test 1 1105)
(carmichael-test 1 1729)
(carmichael-test 1 2465)
(carmichael-test 1 2821)
(carmichael-test 1 6601)



; Exercise 1.28
(define (miller-rabin-fast-prime? n times)
  (cond ((= times 0) true)
        ((miller-rabin-fermat-test n) (miller-rabin-fast-prime? n (- times 1)))
        (else false)))
(define (miller-rabin-fermat-test n)
  (define (try-it a)
    (= (miller-rabin-expmod a (- n 1) n) 1))
  (try-it (+ 1 (random (- n 1)))))
(define (miller-rabin-expmod base exp m)
  (cond ((= exp 0) 1)       
        ((even? exp)
         (define this-mod (miller-rabin-expmod base (/ exp 2) m))
         (if (and
              (not (= this-mod 1))
              (not (= this-mod (- m 1)))
              (= (remainder (square this-mod) m) 1))
             0
             (remainder (square this-mod) m)))
        (else
         (remainder
          (* base (miller-rabin-expmod base (- exp 1) m))
          m))))

(miller-rabin-fast-prime? 561 10)  ; Correctly returns false
(miller-rabin-fast-prime? 1105 10)  ; Correctly returns false
(miller-rabin-fast-prime? 1729 10)  ; Correctly returns false
(miller-rabin-fast-prime? 2465 10)  ; Correctly returns false
(miller-rabin-fast-prime? 2821 10)  ; Correctly returns false
(miller-rabin-fast-prime? 6601 10)  ; Correctly returns false
(miller-rabin-fast-prime? 10007 10)  ; Correctly returns true
(miller-rabin-fast-prime? 1009 10)  ; Correctly returns true
(miller-rabin-fast-prime? 1013 10)  ; Correctly returns true
(miller-rabin-fast-prime? 1019 10)  ; Correctly returns true
(miller-rabin-fast-prime? 100003 10)  ; Correctly returns true
(miller-rabin-fast-prime? 100043 10)  ; Correctly returns true
(miller-rabin-fast-prime? 100019 10)  ; Correctly returns true
(miller-rabin-fast-prime? 7 10)  ; Correctly returns true
(miller-rabin-fast-prime? 1000037 10)  ; Correctly returns true
(miller-rabin-fast-prime? 1000033 10)  ; Correctly returns true
